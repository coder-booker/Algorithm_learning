They are so smart. 
What I can do is to drop some fixed practices for certain algorithms. 

Complexity: 
    1. only nested loop makes more complex result. multiple separate loops are still in O(n)
general: 
    1. try to do it manually once
    2. 可能有用的关键字：相邻/连续、最大最小、以此开头/结尾
    3. 留意题目要求的输出，有时候某些信息不一定需要在算法中被保留（eg 求最大子数组和不需要子数组索引）
    4. 贪心
    5. % 可以用来 range control (189.cpp 轮转数组)
sort: 
    c++ normally consumes nlogn
in-place algorithm: 
    1. use the original/part of array to store the result. then O(1) space complexity
    2. use a single extra variable to store the result. then O(1) space complexity

dp: 
    1. how to define dp[i]?
    2. how to update dp[i+1] from dp[i]?
    3. how to get the result from dp?
    some abstract mindset: 
        how to keep transfering the state? (states can be +ve or -ve states that benefit or harm the result respectively)
moving windows:
    1. when to move left and right?
    2. when to stop moving left and right?
    3. how to update the result?
    4. 关键不在于怎么停在最优的left和right，而在于怎么遍历所有有利可能性
    there are two types of moving windows: 
        1. left = right = begin;
        2. left = begin, right = end;
linked list: 
    1. typical questions: 
        nth node from the end.
        half from the end. 
        dummy list
        intersection (linked list concatentation)
    2. dummy node can be used as the head node of modified linked list (so even if it is the original first node that changed, the dummy node is still the head)
    3. delete ==> 1 ptr. swap ==> 2 ptrs?
    4. recursion is useful but costly. iteration is space saving but harder to implement.

to_learn:
    2. 分治法
    3. 旋转图像
    4. 二叉树、红黑树、avl树
    
to do:
